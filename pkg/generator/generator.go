package generator

import (
	"fmt"
	"strings"

	"github.com/coollabsio/coolpack/pkg/app"
)

// Generator generates build files from a plan
type Generator struct {
	plan *app.Plan
}

// New creates a new generator from a plan
func New(plan *app.Plan) *Generator {
	return &Generator{plan: plan}
}

// GenerateDockerfile generates a Dockerfile based on the plan
func (g *Generator) GenerateDockerfile() (string, error) {
	switch g.plan.Provider {
	case "node":
		return g.generateNodeDockerfile()
	default:
		return "", fmt.Errorf("unsupported provider: %s", g.plan.Provider)
	}
}

func (g *Generator) generateNodeDockerfile() (string, error) {
	var sb strings.Builder

	nodeVersion := g.plan.LanguageVersion
	if nodeVersion == "" {
		nodeVersion = "24"
	}

	outputType := "server"
	if ot, ok := g.plan.Metadata["output_type"].(string); ok {
		outputType = ot
	}

	// Determine base image variant (COOLPACK_BASE_IMAGE overrides default)
	var baseImage string
	if customBase, ok := g.plan.Metadata["base_image"].(string); ok && customBase != "" {
		baseImage = customBase
	} else if g.plan.PackageManager == "bun" {
		// Use official bun image when bun is the package manager
		bunVersion := "latest"
		if g.plan.PackageManagerVersion != "" {
			bunVersion = g.plan.PackageManagerVersion
		}
		if bunVersion != "latest" {
			baseImage = fmt.Sprintf("oven/bun:%s-slim", bunVersion)
		} else {
			baseImage = "oven/bun:latest"
		}
	} else {
		baseImage = fmt.Sprintf("node:%s-slim", nodeVersion)
	}

	// Write Dockerfile with BuildKit syntax for cache mounts
	sb.WriteString("# syntax=docker/dockerfile:1\n")
	sb.WriteString("# Generated by Coolpack\n")
	sb.WriteString(fmt.Sprintf("# Provider: %s, Framework: %s, Output: %s\n\n", g.plan.Provider, g.plan.Framework, outputType))

	if outputType == "static" {
		g.writeStaticDockerfile(&sb, baseImage)
	} else {
		g.writeServerDockerfile(&sb, baseImage)
	}

	return sb.String(), nil
}

func (g *Generator) writeServerDockerfile(sb *strings.Builder, baseImage string) {
	pm := g.plan.PackageManager
	if pm == "" {
		pm = "npm"
	}

	// Build stage
	sb.WriteString(fmt.Sprintf("FROM %s AS builder\n", baseImage))
	sb.WriteString("WORKDIR /app\n\n")

	// Install APT packages for native dependencies
	g.writeAptInstall(sb)

	// Declare build-time ARGs
	g.writeBuildArgs(sb)

	// Install package manager if not npm
	g.writePackageManagerInstall(sb, pm)

	// Copy package files first (for better caching)
	g.writeCopyPackageFiles(sb, pm)

	// Install dependencies with cache mount
	cacheMount := g.getCacheMount(pm)
	sb.WriteString(fmt.Sprintf("RUN %s%s\n\n", cacheMount, g.plan.InstallCommand))

	// Copy source code
	sb.WriteString("COPY . .\n\n")

	// Build if there's a build command
	if g.plan.BuildCommand != "" {
		buildCacheMount := g.getBuildCacheMount()
		sb.WriteString(fmt.Sprintf("RUN %s%s\n\n", buildCacheMount, g.plan.BuildCommand))
	}

	// Production stage
	sb.WriteString(fmt.Sprintf("FROM %s AS runner\n", baseImage))
	sb.WriteString("WORKDIR /app\n\n")

	// Install package manager if not npm
	g.writePackageManagerInstall(sb, pm)

	// Create non-root user
	sb.WriteString("RUN groupadd --gid 1001 coolgroup &&\\\n")
	sb.WriteString("    useradd --uid 1001 --gid 1001 cooluser\n\n")

	// Set production environment (build envs are NOT included - pass at runtime via docker run -e)
	sb.WriteString("ENV NODE_ENV=production\n\n")

	// Copy built application
	g.writeServerCopyStatements(sb, pm)

	// Set ownership and switch to non-root user
	sb.WriteString("RUN chown -R cooluser:coolgroup /app\n")
	sb.WriteString("USER cooluser\n\n")

	// Expose port
	sb.WriteString("EXPOSE 3000\n\n")

	// Start command
	if g.plan.StartCommand != "" {
		sb.WriteString(fmt.Sprintf("CMD %s\n", g.formatCmdCommand(g.plan.StartCommand)))
	} else {
		sb.WriteString("CMD [\"node\", \"index.js\"]\n")
	}
}

func (g *Generator) writeStaticDockerfile(sb *strings.Builder, baseImage string) {
	pm := g.plan.PackageManager
	if pm == "" {
		pm = "npm"
	}

	// Build stage
	sb.WriteString(fmt.Sprintf("FROM %s AS builder\n", baseImage))
	sb.WriteString("WORKDIR /app\n\n")

	// Install APT packages for native dependencies
	g.writeAptInstall(sb)

	// Declare build-time ARGs
	g.writeBuildArgs(sb)

	// Install package manager if not npm
	g.writePackageManagerInstall(sb, pm)

	// Copy package files first (for better caching)
	g.writeCopyPackageFiles(sb, pm)

	// Install dependencies with cache mount
	cacheMount := g.getCacheMount(pm)
	sb.WriteString(fmt.Sprintf("RUN %s%s\n\n", cacheMount, g.plan.InstallCommand))

	// Copy source code
	sb.WriteString("COPY . .\n\n")

	// Build
	if g.plan.BuildCommand != "" {
		buildCacheMount := g.getBuildCacheMount()
		sb.WriteString(fmt.Sprintf("RUN %s%s\n\n", buildCacheMount, g.plan.BuildCommand))
	}

	// Determine static server (caddy is default, nginx is option)
	staticServer := "caddy"
	if ss, ok := g.plan.Metadata["static_server"].(string); ok && ss != "" {
		staticServer = ss
	}

	outputDir := g.getStaticOutputDir()

	if staticServer == "nginx" {
		g.writeNginxStaticStage(sb, outputDir)
	} else {
		g.writeCaddyStaticStage(sb, outputDir)
	}
}

func (g *Generator) writeCaddyStaticStage(sb *strings.Builder, outputDir string) {
	// Serve stage - use Caddy for static files (default)
	sb.WriteString("FROM caddy:alpine AS runner\n\n")

	// Create non-root user
	sb.WriteString("RUN addgroup --system --gid 1001 coolgroup && \\\n")
	sb.WriteString("    adduser --system --uid 1001 -G coolgroup cooluser\n\n")

	// Copy built static files
	sb.WriteString(fmt.Sprintf("COPY --from=builder /app/%s /srv\n\n", outputDir))

	// Add SPA Caddyfile if needed
	if g.isSPA() {
		sb.WriteString("# SPA routing: serve index.html for all routes\n")
		sb.WriteString("RUN printf '%s\\n' ':80 {' '    root * /srv' '    try_files {path} /index.html' '    file_server' '}' > /etc/caddy/Caddyfile\n\n")
	}

	// Set ownership
	sb.WriteString("RUN chown -R cooluser:coolgroup /srv\n\n")

	sb.WriteString("USER cooluser\n\n")

	// Expose port
	sb.WriteString("EXPOSE 80\n\n")

	// Caddy command
	if g.isSPA() {
		// Use Caddyfile for SPA routing
		sb.WriteString("CMD [\"caddy\", \"run\", \"--config\", \"/etc/caddy/Caddyfile\"]\n")
	} else {
		sb.WriteString("CMD [\"caddy\", \"file-server\", \"--root\", \"/srv\", \"--listen\", \":80\"]\n")
	}
}

func (g *Generator) writeNginxStaticStage(sb *strings.Builder, outputDir string) {
	// Serve stage - use nginx for static files
	sb.WriteString("FROM nginx:alpine AS runner\n\n")

	// Create non-root user and configure nginx to run on port 80 as non-root
	sb.WriteString("RUN addgroup --system --gid 1001 coolgroup && \\\n")
	sb.WriteString("    adduser --system --uid 1001 -G coolgroup cooluser && \\\n")
	sb.WriteString("    apk add --no-cache libcap && \\\n")
	sb.WriteString("    setcap 'cap_net_bind_service=+ep' /usr/sbin/nginx && \\\n")
	sb.WriteString("    sed -i '/user  nginx;/d' /etc/nginx/nginx.conf && \\\n")
	sb.WriteString("    chown -R cooluser:coolgroup /usr/share/nginx/html && \\\n")
	sb.WriteString("    chown -R cooluser:coolgroup /var/cache/nginx && \\\n")
	sb.WriteString("    chown -R cooluser:coolgroup /var/log/nginx && \\\n")
	sb.WriteString("    touch /var/run/nginx.pid && \\\n")
	sb.WriteString("    chown cooluser:coolgroup /var/run/nginx.pid\n\n")

	// Copy built static files to nginx
	sb.WriteString(fmt.Sprintf("COPY --from=builder /app/%s /usr/share/nginx/html\n\n", outputDir))

	// Add SPA nginx config if needed
	if g.isSPA() {
		sb.WriteString("# SPA routing: serve index.html for all routes\n")
		sb.WriteString("RUN echo 'server { \\\n")
		sb.WriteString("    listen 80; \\\n")
		sb.WriteString("    root /usr/share/nginx/html; \\\n")
		sb.WriteString("    index index.html; \\\n")
		sb.WriteString("    location / { \\\n")
		sb.WriteString("        try_files $uri $uri/ /index.html; \\\n")
		sb.WriteString("    } \\\n")
		sb.WriteString("}' > /etc/nginx/conf.d/default.conf\n\n")
	}

	sb.WriteString("USER cooluser\n\n")

	// Expose port
	sb.WriteString("EXPOSE 80\n\n")

	sb.WriteString("CMD [\"nginx\", \"-g\", \"daemon off;\"]\n")
}

// isSPA returns true if the application is a Single Page Application
func (g *Generator) isSPA() bool {
	if isSPA, ok := g.plan.Metadata["is_spa"].(bool); ok {
		return isSPA
	}
	return false
}

func (g *Generator) writePackageManagerInstall(sb *strings.Builder, pm string) {
	switch pm {
	case "pnpm":
		version := "latest"
		if g.plan.PackageManagerVersion != "" {
			version = g.plan.PackageManagerVersion
		}
		sb.WriteString(fmt.Sprintf("RUN corepack enable && corepack prepare pnpm@%s --activate\n\n", version))
	case "yarn":
		// yarn v1 is included with node, yarn berry needs corepack
		if g.plan.PackageManagerVersion != "" && !strings.HasPrefix(g.plan.PackageManagerVersion, "1.") {
			sb.WriteString("RUN corepack enable\n\n")
		}
	case "bun":
		// bun is already installed when using oven/bun image
		// Only install if using a custom base image (non-bun)
		if customBase, ok := g.plan.Metadata["base_image"].(string); ok && customBase != "" && !strings.Contains(customBase, "bun") {
			if g.plan.PackageManagerVersion != "" {
				sb.WriteString(fmt.Sprintf("RUN npm install -g bun@%s\n\n", g.plan.PackageManagerVersion))
			} else {
				sb.WriteString("RUN npm install -g bun\n\n")
			}
		}
	}
}

func (g *Generator) writeCopyPackageFiles(sb *strings.Builder, pm string) {
	sb.WriteString("COPY package.json ")

	switch pm {
	case "npm":
		sb.WriteString("package-lock.json* ")
	case "yarn":
		sb.WriteString("yarn.lock* .yarnrc.yml* ")
	case "pnpm":
		sb.WriteString("pnpm-lock.yaml* ")
	case "bun":
		sb.WriteString("bun.lockb* bun.lock* ")
	}

	sb.WriteString("./\n\n")
}

func (g *Generator) writeServerCopyStatements(sb *strings.Builder, pm string) {
	framework := g.plan.Framework

	// Copy node_modules for production
	sb.WriteString("COPY --from=builder /app/node_modules ./node_modules\n")

	// Framework-specific copy statements
	switch framework {
	case "nextjs":
		sb.WriteString("COPY --from=builder /app/.next ./.next\n")
		sb.WriteString("COPY --from=builder /app/public ./public\n")
		sb.WriteString("COPY --from=builder /app/package.json ./\n")
	case "nuxt":
		sb.WriteString("COPY --from=builder /app/.output ./.output\n")
	case "remix":
		sb.WriteString("COPY --from=builder /app/build ./build\n")
		sb.WriteString("COPY --from=builder /app/public ./public\n")
		sb.WriteString("COPY --from=builder /app/package.json ./\n")
	case "astro":
		sb.WriteString("COPY --from=builder /app/dist ./dist\n")
	case "sveltekit":
		sb.WriteString("COPY --from=builder /app/build ./build\n")
		sb.WriteString("COPY --from=builder /app/package.json ./\n")
	case "solid-start", "tanstack-start":
		sb.WriteString("COPY --from=builder /app/.output ./.output\n")
	default:
		// Generic: copy everything
		sb.WriteString("COPY --from=builder /app .\n")
	}
	sb.WriteString("\n")
}

func (g *Generator) getStaticOutputDir() string {
	// Check for user override first (CLI flag or COOLPACK_SPA_OUTPUT_DIR env var)
	if override, ok := g.plan.Metadata["output_dir_override"].(string); ok && override != "" {
		return override
	}

	// Framework-specific defaults
	framework := g.plan.Framework

	switch framework {
	case "nextjs":
		return "out"
	case "nuxt":
		return ".output/public"
	case "astro":
		return "dist"
	case "gatsby":
		return "public"
	case "vite", "create-react-app":
		return "dist"
	case "angular":
		return "dist"
	case "sveltekit":
		return "build"
	case "solid-start", "tanstack-start":
		return ".output/public"
	case "eleventy":
		return "_site"
	default:
		return "dist"
	}
}

func (g *Generator) formatCmdCommand(cmd string) string {
	// Convert command string to JSON array format for CMD
	parts := strings.Fields(cmd)
	quoted := make([]string, len(parts))
	for i, p := range parts {
		quoted[i] = fmt.Sprintf("\"%s\"", p)
	}
	return "[" + strings.Join(quoted, ", ") + "]"
}

// getCacheMount returns the BuildKit cache mount for the package manager (install phase)
func (g *Generator) getCacheMount(pm string) string {
	var caches []string

	// Package manager cache
	switch pm {
	case "npm":
		caches = append(caches, "--mount=type=cache,target=/root/.npm")
	case "yarn":
		// Yarn v1 uses /usr/local/share/.cache/yarn, Yarn Berry uses .yarn/cache (local)
		if g.plan.PackageManagerVersion != "" && !strings.HasPrefix(g.plan.PackageManagerVersion, "1.") {
			caches = append(caches, "--mount=type=cache,target=/root/.yarn/berry/cache")
		} else {
			caches = append(caches, "--mount=type=cache,target=/usr/local/share/.cache/yarn")
		}
	case "pnpm":
		caches = append(caches, "--mount=type=cache,target=/root/.local/share/pnpm/store")
	case "bun":
		caches = append(caches, "--mount=type=cache,target=/root/.bun/install/cache")
	default:
		caches = append(caches, "--mount=type=cache,target=/root/.npm")
	}

	// Cypress cache (downloads happen during install)
	if _, ok := g.plan.Metadata["has_cypress"].(bool); ok {
		caches = append(caches, "--mount=type=cache,target=/root/.cache/Cypress")
	}

	return strings.Join(caches, " ") + " "
}

// getBuildCacheMount returns BuildKit cache mounts for the build phase
// Caches framework-specific build artifacts and custom directories
func (g *Generator) getBuildCacheMount() string {
	var caches []string

	// Framework-specific build caches
	switch g.plan.Framework {
	case "nextjs":
		caches = append(caches, "--mount=type=cache,target=/app/.next/cache")
	case "remix", "react-router":
		caches = append(caches, "--mount=type=cache,target=/app/.cache")
		caches = append(caches, "--mount=type=cache,target=/app/.react-router")
	case "vite", "tanstack-start":
		caches = append(caches, "--mount=type=cache,target=/app/node_modules/.vite")
	case "astro":
		caches = append(caches, "--mount=type=cache,target=/app/node_modules/.astro")
	case "nuxt":
		caches = append(caches, "--mount=type=cache,target=/app/node_modules/.cache")
	}

	// Default node_modules/.cache for all frameworks (webpack, babel, eslint, etc.)
	caches = append(caches, "--mount=type=cache,target=/app/node_modules/.cache")

	// Moon repo cache if detected
	if _, ok := g.plan.Metadata["has_moon"].(bool); ok {
		caches = append(caches, "--mount=type=cache,target=/app/.moon/cache")
	}

	// Custom cache directories from package.json
	if customDirs, ok := g.plan.Metadata["cache_directories"].([]string); ok {
		for _, dir := range customDirs {
			// Ensure the path is within /app
			if !strings.HasPrefix(dir, "/") {
				caches = append(caches, fmt.Sprintf("--mount=type=cache,target=/app/%s", dir))
			}
		}
	}

	// Deduplicate caches
	seen := make(map[string]bool)
	unique := make([]string, 0, len(caches))
	for _, c := range caches {
		if !seen[c] {
			seen[c] = true
			unique = append(unique, c)
		}
	}

	if len(unique) == 0 {
		return ""
	}

	return strings.Join(unique, " ") + " "
}

// writeBuildArgs writes ARG and ENV declarations for build-time environment variables
func (g *Generator) writeBuildArgs(sb *strings.Builder) {
	if len(g.plan.BuildEnv) == 0 {
		return
	}

	// Write ARG declarations (sorted for consistent output)
	keys := g.getSortedEnvKeys(g.plan.BuildEnv)
	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("ARG %s\n", key))
	}
	// Also set as ENV so they're available to build commands (npm run build, etc.)
	for _, key := range keys {
		sb.WriteString(fmt.Sprintf("ENV %s=$%s\n", key, key))
	}
	sb.WriteString("\n")
}

// getSortedEnvKeys returns environment variable keys in sorted order
func (g *Generator) getSortedEnvKeys(env map[string]string) []string {
	keys := make([]string, 0, len(env))
	for k := range env {
		keys = append(keys, k)
	}
	// Sort for consistent output
	for i := 0; i < len(keys)-1; i++ {
		for j := i + 1; j < len(keys); j++ {
			if keys[i] > keys[j] {
				keys[i], keys[j] = keys[j], keys[i]
			}
		}
	}
	return keys
}

// writeAptInstall writes APT package installation for native and custom packages
func (g *Generator) writeAptInstall(sb *strings.Builder) {
	// Collect all packages: native (apt_packages) + custom (custom_packages)
	var allPackages []string

	if aptPackages, ok := g.plan.Metadata["apt_packages"].([]string); ok {
		allPackages = append(allPackages, aptPackages...)
	}

	if customPackages, ok := g.plan.Metadata["custom_packages"].([]string); ok {
		allPackages = append(allPackages, customPackages...)
	}

	if len(allPackages) == 0 {
		return
	}

	// Deduplicate
	seen := make(map[string]bool)
	unique := make([]string, 0, len(allPackages))
	for _, pkg := range allPackages {
		if !seen[pkg] {
			seen[pkg] = true
			unique = append(unique, pkg)
		}
	}

	// Add comment about what packages are being installed
	if nativePkgs, ok := g.plan.Metadata["native_packages"].([]string); ok && len(nativePkgs) > 0 {
		sb.WriteString(fmt.Sprintf("# Native dependencies detected: %s\n", strings.Join(nativePkgs, ", ")))
	}
	if customPkgs, ok := g.plan.Metadata["custom_packages"].([]string); ok && len(customPkgs) > 0 {
		sb.WriteString(fmt.Sprintf("# Custom packages: %s\n", strings.Join(customPkgs, ", ")))
	}

	sb.WriteString("RUN apt-get update && apt-get install -y --no-install-recommends \\\n")
	for _, pkg := range unique {
		sb.WriteString(fmt.Sprintf("    %s \\\n", pkg))
	}
	sb.WriteString("    && rm -rf /var/lib/apt/lists/*\n\n")
}
